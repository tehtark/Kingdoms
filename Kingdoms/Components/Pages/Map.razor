@page "/map"
@using Kingdoms.Application.Features.Holding.Queries
@using Kingdoms.Application.Features.Map
@using Kingdoms.Application.Features.Player.Queries
@using Kingdoms.Application.Services
@using Kingdoms.Components.Carousel
@using Newtonsoft.Json

@attribute [Authorize]

@inject HoldingService _holdingService
@inject PlayerService _playerService
@inject ISnackbar _snackbar

@if (!_loaded && _selectedHolding == null)
{
    <Loading />
}
else
{
    <MudGrid>
        <MudItem xs="10">
            <MudGrid>
                <MudItem xs="12">
                    <MudButton FullWidth="true" OnClick="OnClick">
                        <HoldingCarousel Holdings="_playerHoldings" SelectedHoldingChanged="OnSelectedHoldingChanged"></HoldingCarousel>
                    </MudButton>
                </MudItem>
                <MudItem xs="12">
                    <SfMaps @ref=_sfMaps Background="#98c5f5" Width="100%" Height="calc(90vh - (var(--mud-appbar-height)))">
                        <MapsEvents OnMarkerClick="OnMarkerClickEvent" OnPan="OnPanEvent" OnPanComplete="OnPanCompleteEvent" OnZoomComplete="@OnZoomCompleteEvent" />
                        <MapsAreaSettings Background="#98c5f5" />
                        <MapsCenterPosition Longitude="@_selectedHolding.Longitude" Latitude="@_selectedHolding.Latitude"></MapsCenterPosition>
                        <MapsZoomSettings Enable="_canZoom" ZoomFactor="_zoomFactor" EnablePanning="_canPan" />
                        <MapsLayers>
                            <MapsLayer ShapeData='new {dataOptions= _map }' TValue="string">
                                <MapsLayerSelectionSettings Enable="_canSelectLayer" Fill="green">
                                    <MapsLayerSelectionBorder Color="White" Width="2"></MapsLayerSelectionBorder>
                                </MapsLayerSelectionSettings>
                                <MapsShapeSettings ColorValuePath="Color" />
                                <MapsMarkerSettings>
                                    <MapsMarker Visible="_markersVisible" DataSource="@_playerHoldings" TValue="Holding" Height="40" Width="40" AnimationDuration=0 Shape="Syncfusion.Blazor.Maps.MarkerType.Image" ImageUrl="@Presentation.Shared.Icons.Player_Village">
                                        <MapsMarkerSelectionSettings Enable="_canSelectMarker"></MapsMarkerSelectionSettings>
                                    </MapsMarker>
                                    <MapsMarker Visible="_markersVisible" DataSource="@_enemyHoldings" TValue="Holding" Height="40" Width="40" AnimationDuration=0 Shape="Syncfusion.Blazor.Maps.MarkerType.Image" ImageUrl="@Presentation.Shared.Icons.Village">
                                        <MapsMarkerSelectionSettings Enable="_canSelectMarker"></MapsMarkerSelectionSettings>
                                    </MapsMarker>
                                </MapsMarkerSettings>
                                <MapsDataLabelSettings Visible="true" LabelPath="State"></MapsDataLabelSettings>
                            </MapsLayer>
                        </MapsLayers>
                    </SfMaps>
                </MudItem>
            </MudGrid>
        </MudItem>
        <MudItem xs="2">
            <MudPaper Height="100%" Width="100%">
                <MudStack Justify="Justify.Center" AlignItems="AlignItems.Center">
                    <h2>
                        Holding Information
                    </h2>
                    Player:
                    <MudButton>Attack</MudButton>
                    <MudButton>Scout</MudButton>
                    <MudButton>Trade</MudButton>
                </MudStack>
            </MudPaper>
        </MudItem>
    </MudGrid>
}
@code {
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationState { get; set; }
    private string? _playerId;

    #region Map Options

    private SfMaps? _sfMaps;
    private string? _map;
    private bool _loaded = false;
    private bool _canSelectMarker = true;
    private bool _canSelectLayer = false;
    private int _zoomFactor = 10;
    private bool _canZoom = true;
    private bool _canPan = true;
    private bool _markersVisible = true;

    #endregion

    private List<Holding>? _enemyHoldings;
    private List<Holding>? _playerHoldings;
    private Holding? _selectedHolding;

    protected override async Task OnInitializedAsync()
    {
        await Task.Delay(Globals.DefaultDelay);

        if (AuthenticationState is not null) _playerId = await _playerService.GetPlayerIdAsync(await AuthenticationState);

        if (_playerId is not null)
        {
            _playerHoldings = await _holdingService.GetPlayerHoldings(_playerId);
            _enemyHoldings = await _holdingService.GetEnemyHoldingsAsync(_playerId);
            _selectedHolding = _playerHoldings.FirstOrDefault();
        }

        _map = Globals.Map;
        _loaded = true;
    }

    private async Task OnMarkerClickEvent(Syncfusion.Blazor.Maps.MarkerClickEventArgs args)
    {
        args.Data.TryGetValue("Id", out string? holdingId);
        if (string.IsNullOrEmpty(holdingId)) return;
        _selectedHolding = await _holdingService.GetHoldingAsync(new Guid(holdingId));
    }

    public Task OnPanEvent(Syncfusion.Blazor.Maps.MapPanEventArgs args)
    {
        return Task.FromResult(_canSelectMarker = false);

    }

    public async Task OnPanCompleteEvent(Syncfusion.Blazor.Maps.MapPanEventArgs args)
    {
        await Task.Delay(500);

        _canSelectMarker = true;
    }

    public Task OnZoomCompleteEvent(Syncfusion.Blazor.Maps.MapZoomEventArgs args)
    {
        if (args.Scale < 2)
        {
            _markersVisible = false;
        }
        else
        {
            _markersVisible = true;
        }
        return Task.CompletedTask;
    }

    public Task OnSelectedHoldingChanged(Holding holding)
    {
        _selectedHolding = holding;
        return Task.CompletedTask;
    }

    private void OnClick()
    {

    }

    // public Task OnSelectedIndexChanged(int value)
    // {
    //     _zoomFactor = 10;
    //     _selectedHoldingIndex = value;
    //     return Task.CompletedTask;
    // }
}