@page "/map"
@using Kingdoms.Application.Features.Holding.Queries
@using Kingdoms.Application.Features.Map
@using Kingdoms.Application.Features.Player.Queries
@using Kingdoms.Application.Services
@using Kingdoms.Components.Carousel
@using Newtonsoft.Json

@implements IAsyncDisposable

@attribute [Authorize]

@inject GameTickService _gameTickService
@inject HoldingService _holdingService
@inject PlayerService _playerService
@inject ISnackbar _snackbar

@if (!_loaded && _targetedHolding == null)
{
    <Loading />
}
else
{
    <MudGrid>
        <MudItem xs="10">
            <MudGrid>
                <MudItem xs="12">
                    <MudButton FullWidth="true">
                        <HoldingCarousel Holdings="_playerHoldings" SelectedHoldingChanged="OnCarouselHoldingChanged"></HoldingCarousel>
                    </MudButton>
                </MudItem>
                <MudItem xs="12">
                    <SfMaps @ref=_sfMaps Background="#98c5f5" Width="100%" Height="calc(90vh - (var(--mud-appbar-height)))">
                        <MapsEvents OnMarkerClick="OnMarkerClickEvent" OnPan="OnPanEvent" OnPanComplete="OnPanCompleteEvent" OnZoomComplete="@OnZoomCompleteEvent" />
                        <MapsAreaSettings Background="#98c5f5" />
                        <MapsCenterPosition Longitude="@_targetedHolding.Longitude" Latitude="@_targetedHolding.Latitude"></MapsCenterPosition>
                        <MapsZoomSettings Enable="_canZoom" ZoomFactor="_zoomFactor" EnablePanning="_canPan" />
                        <MapsLayers>
                            <MapsLayer ShapeData='new {dataOptions= _map }' TValue="string">
                                <MapsLayerSelectionSettings Enable="_canSelectLayer" Fill="green">
                                    <MapsLayerSelectionBorder Color="White" Width="2"></MapsLayerSelectionBorder>
                                </MapsLayerSelectionSettings>
                                <MapsShapeSettings ColorValuePath="Color" />
                                <MapsMarkerSettings>
                                    <MapsMarker Visible="_markersVisible" DataSource="@_playerHoldings" TValue="Holding" Height="40" Width="40" AnimationDuration=0 Shape="Syncfusion.Blazor.Maps.MarkerType.Image" ImageUrl="@Presentation.Shared.Icons.Player_Village">
                                        <MapsMarkerSelectionSettings Enable="_canSelectMarker"></MapsMarkerSelectionSettings>
                                    </MapsMarker>
                                    <MapsMarker Visible="_markersVisible" DataSource="@_enemyHoldings" TValue="Holding" Height="40" Width="40" AnimationDuration=0 Shape="Syncfusion.Blazor.Maps.MarkerType.Image" ImageUrl="@Presentation.Shared.Icons.Village">
                                        <MapsMarkerSelectionSettings Enable="_canSelectMarker"></MapsMarkerSelectionSettings>
                                    </MapsMarker>
                                </MapsMarkerSettings>
                                <MapsDataLabelSettings Visible="true" LabelPath="State"></MapsDataLabelSettings>
                            </MapsLayer>
                        </MapsLayers>
                    </SfMaps>
                </MudItem>
            </MudGrid>
        </MudItem>
        <MudItem xs="2">
            <MudStack Justify="Justify.Center" AlignItems="AlignItems.Center">
                <HoldingInformation Holding="_targetedHolding" />
                <MudButton FullWidth="true" Variant="Variant.Filled">Attack</MudButton>
                <MudButton FullWidth="true" Variant="Variant.Filled">Scout</MudButton>
                <MudButton FullWidth="true" Variant="Variant.Filled">Trade</MudButton>
            </MudStack>
        </MudItem>
    </MudGrid>
}
@code {
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationState { get; set; }
    private string? _playerId;

    #region Map Options

    private SfMaps? _sfMaps;
    private string? _map;
    private bool _loaded = false;
    private bool _canSelectMarker = true;
    private bool _canSelectLayer = false;
    private int _zoomFactor = 10;
    private bool _canZoom = true;
    private bool _canPan = true;
    private bool _markersVisible = true;

    #endregion

    private List<Holding>? _enemyHoldings;
    private List<Holding>? _playerHoldings;
    private Holding? _targetedHolding;
    private Holding? _currentHolding;

    protected override async Task OnInitializedAsync()
    {
        await Task.Delay(Globals.DefaultDelay);

        if (AuthenticationState is not null) _playerId = await _playerService.GetPlayerIdAsync(await AuthenticationState);

        if (_playerId is not null)
        {
            _playerHoldings = await _holdingService.GetPlayerHoldings(_playerId);
            _enemyHoldings = await _holdingService.GetEnemyHoldingsAsync(_playerId);
            _targetedHolding = _playerHoldings.FirstOrDefault();
        }

        _map = Globals.Map;

        _gameTickService.OnTickUpdated += OnTickUpdated;

        _loaded = true;
    }

    ValueTask IAsyncDisposable.DisposeAsync()
    {
        _gameTickService.OnTickUpdated -= OnTickUpdated;
        return ValueTask.CompletedTask;
    }

    public async Task OnTickUpdated()
    {
        _snackbar.Add("Tick Updated", Severity.Info);
    }

    private async Task OnMarkerClickEvent(Syncfusion.Blazor.Maps.MarkerClickEventArgs args)
    {
        args.Data.TryGetValue("Id", out string? holdingId);
        if (string.IsNullOrEmpty(holdingId)) return;
        _targetedHolding = await _holdingService.GetHoldingAsync(new Guid(holdingId));
    }

    public Task OnPanEvent(Syncfusion.Blazor.Maps.MapPanEventArgs args)
    {
        return Task.FromResult(_canSelectMarker = false);

    }

    public async Task OnPanCompleteEvent(Syncfusion.Blazor.Maps.MapPanEventArgs args)
    {
        await Task.Delay(500);

        _canSelectMarker = true;
    }

    public Task OnZoomCompleteEvent(Syncfusion.Blazor.Maps.MapZoomEventArgs args)
    {
        if (args.Scale < 2)
        {
            _markersVisible = false;
        }
        else
        {
            _markersVisible = true;
        }
        return Task.CompletedTask;
    }

    public Task OnCarouselHoldingChanged(Holding holding)
    {
        _targetedHolding = holding;
        _currentHolding = holding;
        return Task.CompletedTask;
    }
}